# 비정규화

정규화를 통해 얻은 안정성을 일정 부분 포기하고 읽기 성능, 단순화된 쿼리, 캐시 친화성을 얻는 전략이다.

## 사용 사례
- 대시보드/리포트처럼 조인 비용이 큰 다중 테이블 집계를 자주 수행할 때.
- 이벤트 소싱 또는 CQRS의 `read model` 을 구성할 때.
- 캐시 미스 비용이 높은 서비스에서 `materialized view` 나 집계 테이블을 유지할 때.

## 기법
- **중복 컬럼 추가**: 예) `order` 테이블에 `customer_name` 을 캐시해 조회 시 조인을 생략.
- **집계 테이블**: 일별 매출, 카테고리별 카운트 등을 미리 계산한 테이블 유지.
- **JSON/문서형 컬럼**: 스키마 변경 없이 복잡한 구조를 한 컬럼에 저장 (PostgreSQL JSONB 등).
- **Precomputed Join**: 조회 패턴에 맞춘 뷰/테이블을 주기적으로 빌드.

## 주의 사항
- 중복 데이터의 동기화 전략이 필요하다 (트리거, 배치, CDC 등).
- 변경 트랜잭션이 늘어나거나 락 경합이 심해질 수 있어 단위 테스트/부하 테스트를 통해 영향 범위를 확인한다.
- 비정규화 구조는 문서화하고, 생성/갱신 파이프라인을 코드화하여 재현 가능하게 만든다.

## 운영 패턴
- `operations/publication` 과정에서 정규화된 소스 → 비정규화 뷰를 생성하는 스크립트를 포함한다.
- 변경 추적을 위해 버전 컬럼, 생성/수정 일시를 저장하여 역추적 가능하게 한다.
- 필요시 데이터 마트, ElasticSearch, Redis 등 별도 스토어로 동기화하여 읽기 부하를 분산한다.
